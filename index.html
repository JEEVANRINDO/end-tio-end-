<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure Private Chat - Military Grade Encryption</title>
    <style>
        /* Base styles */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --whatsapp-green: #25D366; --whatsapp-dark: #075E54;
            --whatsapp-light: #128C7E; --chat-bg: #e5ddd5;
            --message-sent: #dcf8c6; --message-received: #ffffff;
            --border-color: #e0e0e0; --error-color: #e74c3c; --warning-color: #f39c12;
        }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background: var(--chat-bg); 
            height: 100vh; 
            overflow: hidden; 
        }
        
        /* Screen Management */
        .screen { 
            display: none; 
            height: 100vh; 
            width: 100%;
        }
        .screen.active { 
            display: flex; 
            flex-direction: column; 
        }
        
        /* Auth Screens */
        #auth-screen {
            background: linear-gradient(135deg, var(--whatsapp-dark) 0%, var(--whatsapp-light) 100%);
            justify-content: center;
            align-items: center;
        }
        .auth-container {
            background: white;
            padding: 2.5rem;
            border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            width: 90%;
            max-width: 400px;
            text-align: center;
        }
        .auth-form input {
            width: 100%;
            padding: 14px;
            margin: 10px 0;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 16px;
        }
        .auth-buttons button {
            width: 100%;
            padding: 14px;
            margin: 8px 0;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }
        #signup-btn { background: var(--whatsapp-green); color: white; }
        #signin-btn { background: var(--whatsapp-dark); color: white; }
        
        /* Security-specific styles */
        .security-indicator {
            display: flex; 
            align-items: center; 
            gap: 8px; 
            padding: 8px 12px;
            background: #e8f5e8; 
            border-radius: 8px; 
            margin: 10px 0;
            font-size: 0.8rem; 
            color: #2e7d32;
        }
        .security-warning {
            background: #ffebee;
            color: #c62828;
        }
        .key-management {
            background: #f3e5f5; 
            border-radius: 8px; 
            padding: 1rem; 
            margin: 1rem 0;
        }
        .key-fingerprint {
            font-family: monospace; 
            word-break: break-all; 
            background: white;
            padding: 8px; 
            border-radius: 4px; 
            margin: 8px 0; 
            font-size: 0.7rem;
        }
        .verification-section {
            border: 2px solid #4caf50; 
            border-radius: 8px; 
            padding: 1rem;
            margin: 1rem 0; 
            background: #f1f8e9;
        }
        .device-list { margin: 1rem 0; }
        .device-item {
            padding: 0.5rem; 
            border: 1px solid #ddd; 
            border-radius: 4px;
            margin: 0.5rem 0; 
            background: white;
        }
        .verified-badge { 
            color: #4caf50; 
            font-weight: bold; 
        }
        .warning-badge { 
            color: #ff9800; 
            font-weight: bold; 
        }
        .passphrase-input { 
            width: 100%; 
            padding: 12px; 
            margin: 8px 0; 
            border: 2px solid var(--border-color); 
            border-radius: 8px;
        }
        .message-verified { 
            color: #4caf50; 
            font-size: 0.7rem; 
        }
        .message-unverified { 
            color: #ff9800; 
            font-size: 0.7rem; 
        }
        .message-security-error {
            color: #f44336;
            font-size: 0.7rem;
        }
        .qr-code { 
            width: 200px; 
            height: 200px; 
            margin: 1rem auto; 
            border: 2px solid #ddd; 
            border-radius: 8px; 
            padding: 10px;
            background: white;
        }
        .ratchet-status {
            font-size: 0.7rem; 
            color: #666; 
            margin-top: 4px;
        }
        
        /* Chat Screen */
        #chat-screen { background: var(--chat-bg); }
        .chat-header {
            background: var(--whatsapp-dark);
            color: white;
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            height: calc(100vh - 80px);
        }
        .messages-container {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            background: var(--chat-bg);
        }
        .message {
            margin: 8px 0;
            padding: 12px 16px;
            border-radius: 8px;
            max-width: 70%;
            word-wrap: break-word;
            animation: fadeIn 0.3s ease-in;
        }
        .message.sent {
            background: var(--message-sent);
            margin-left: auto;
        }
        .message.received {
            background: var(--message-received);
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .message-input-container {
            background: white;
            border-top: 1px solid var(--border-color);
            padding: 1rem;
        }
        .message-input {
            display: flex;
            gap: 12px;
            align-items: center;
        }
        .message-input input {
            flex: 1;
            padding: 12px 18px;
            border: 2px solid var(--border-color);
            border-radius: 24px;
            outline: none;
            font-size: 15px;
        }
        
        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal.active { display: flex; }
        .modal-content {
            background: white;
            padding: 2rem;
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        /* Utility Classes */
        .error-message { color: var(--error-color); margin-top: 1rem; }
        .hidden { display: none; }
        .text-center { text-align: center; }
        .mt-2 { margin-top: 1rem; }
        .mb-2 { margin-bottom: 1rem; }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>
    <!-- Auth Screen -->
    <div id="auth-screen" class="screen active">
        <div class="auth-container">
            <div class="app-logo">
                <h1>üîí Secure Private Chat</h1>
                <p>Military Grade End-to-End Encryption</p>
            </div>
            <div class="auth-form">
                <input type="email" id="email" placeholder="Email address" value="test@example.com">
                <input type="password" id="password" placeholder="Password" value="123456">
                <div class="auth-buttons">
                    <button id="signup-btn">Create Account</button>
                    <button id="signin-btn">Sign In</button>
                </div>
            </div>
            <div id="auth-error" class="error-message"></div>
        </div>
    </div>

    <!-- Passphrase Setup Screen -->
    <div id="passphrase-screen" class="screen">
        <div class="auth-container">
            <h2>üîê Set Encryption Passphrase</h2>
            <p>This passphrase protects your encryption keys. You'll need it to access your messages.</p>
            <div class="key-management">
                <input type="password" id="passphrase" class="passphrase-input" placeholder="Enter a strong passphrase">
                <input type="password" id="passphrase-confirm" class="passphrase-input" placeholder="Confirm passphrase">
                <div class="security-indicator">
                    <span>üîí</span>
                    <span>Your passphrase is never sent to the server</span>
                </div>
                <button id="setup-encryption-btn">Setup Encryption</button>
            </div>
        </div>
    </div>

    <!-- Passphrase Entry Screen -->
    <div id="unlock-screen" class="screen">
        <div class="auth-container">
            <h2>üîê Unlock Encryption</h2>
            <p>Enter your passphrase to decrypt your messages</p>
            <div class="key-management">
                <input type="password" id="unlock-passphrase" class="passphrase-input" placeholder="Enter your passphrase">
                <div id="unlock-error" class="error-message"></div>
                <button id="unlock-btn">Unlock</button>
                <div class="security-indicator">
                    <span>üîÑ</span>
                    <span><a href="#" id="reset-encryption-link">Reset encryption keys</a> (will lose access to old messages)</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Key Verification Screen -->
    <div id="verification-screen" class="screen">
        <div class="auth-container">
            <h2>üîç Verify Security Codes</h2>
            <p>Compare security codes with other users to prevent MITM attacks</p>
            <div class="verification-section">
                <h4>Your Security Code:</h4>
                <div class="key-fingerprint" id="user-security-code"></div>
                <div class="qr-code" id="qr-code-container">
                    <!-- QR code will be generated here -->
                </div>
                
                <h4>Other Users to Verify:</h4>
                <div id="users-to-verify-list"></div>
            </div>
            <button id="complete-verification-btn">I've Verified Security Codes</button>
            <button id="skip-verification-btn" class="mt-2" style="background: #666;">Skip for Now</button>
        </div>
    </div>

    <!-- Device Approval Screen -->
    <div id="device-approval-screen" class="screen">
        <div class="auth-container">
            <h2>üì± Device Management</h2>
            <p>Review and approve your devices cryptographically</p>
            <div class="key-management">
                <h4>Your Current Device:</h4>
                <div class="key-fingerprint" id="current-device-fingerprint"></div>
                
                <h4>Pending Device Approvals:</h4>
                <div id="pending-devices-list"></div>
                
                <button id="continue-to-chat-btn" class="hidden">Continue to Chat</button>
            </div>
        </div>
    </div>

    <!-- Main Chat Screen -->
    <div id="chat-screen" class="screen">
        <div class="chat-header">
            <div class="header-info">
                <h3>üîí Secure Group Chat</h3>
                <span id="online-count">‚óè 0 online</span>
            </div>
            <div class="header-actions">
                <span id="user-name"></span>
                <button id="security-info-btn">Security</button>
                <button id="logout-btn">Logout</button>
            </div>
        </div>
        
        <div class="chat-container">
            <div id="messages-container" class="messages-container">
                <div class="security-indicator">
                    <span>üîí</span>
                    <span><strong>MILITARY GRADE ENCRYPTION</strong> - All messages are end-to-end encrypted and verified</span>
                </div>
                <div class="welcome-message">
                    <p>Welcome to your secure chat! Start a conversation with end-to-end encryption.</p>
                </div>
            </div>
            
            <div class="message-input-container">
                <div class="message-input">
                    <input type="text" id="message-input" placeholder="Type a secure message..." maxlength="1000">
                    <div class="input-buttons">
                        <button id="file-btn">üìé</button>
                        <button id="send-btn">Send</button>
                    </div>
                </div>
                <div class="input-actions">
                    <span class="char-count"><span id="char-count">0</span>/1000</span>
                    <span class="encryption-status">üîí End-to-end encrypted</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Security Info Modal -->
    <div id="security-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üîí Security Information</h3>
                <button class="close-btn" id="close-security-modal">√ó</button>
            </div>
            <div class="security-info">
                <div class="security-indicator">
                    <span>‚úÖ</span>
                    <span><strong>Military Grade Security Active</strong></span>
                </div>
                
                <div class="key-management">
                    <h4>Encryption Status</h4>
                    <div id="security-status-list"></div>
                    <div class="ratchet-status" id="ratchet-status"></div>
                </div>

                <button id="verify-security-codes-btn" class="mt-2">Verify Security Codes</button>
                <button id="manage-devices-btn" class="mt-2">Manage Devices</button>
                <button id="backup-keys-btn" class="mt-2">Backup Encryption Keys</button>
                <button id="rotate-keys-btn" class="mt-2">Rotate Keys</button>
            </div>
        </div>
    </div>

    <!-- Include QR Code library -->
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-storage-compat.js"></script>

    <!-- Signal Protocol Library -->
    <script src="https://cdn.jsdelivr.net/npm/@privacyresearch/libsignal-protocol-typescript@0.1.0/dist/libsignal-protocol.min.js"></script>

    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBCix7_qzRM8dSopBef0ORyFjvssjV32Lc",
            authDomain: "messaging-app-1bd04.firebaseapp.com",
            projectId: "messaging-app-1bd04",
            storageBucket: "messaging-app-1bd04.firebasestorage.app",
            messagingSenderId: "443693550918",
            appId: "1:443693550918:web:62cb22ffd4056014822947",
            measurementId: "G-P9EWYXGNV2"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        const storage = firebase.storage();

        // ==================== SECURITY CONSTANTS ====================
        const SECURITY_CONFIG = {
            PBKDF2_ITERATIONS: 310000, // OWASP recommended minimum
            KEY_WRAPPING_ALGORITHM: 'AES-GCM',
            KEY_LENGTH: 256,
            MESSAGE_IV_LENGTH: 12,
            SALT_LENGTH: 16,
            MAX_MESSAGE_AGE: 7 * 24 * 60 * 60 * 1000, // 7 days
            MAX_CACHED_MESSAGES: 1000,
            PRE_KEY_AMOUNT: 100
        };

        // ==================== SIGNAL PROTOCOL STORE ====================

        class SignalProtocolStore {
            constructor() {
                this._store = {};
                this.verifiedIdentityKeys = new Map(); // Store verified identity keys for MITM protection
            }

            // Identity
            getIdentityKeyPair() { return this._getItem('identityKey'); }
            setIdentityKeyPair(keyPair) { return this._setItem('identityKey', keyPair); }

            // PreKeys
            getPreKey(keyId) { return this._getItem(`preKey${keyId}`); }
            storePreKey(keyId, keyPair) { return this._setItem(`preKey${keyId}`, keyPair); }
            removePreKey(keyId) { return this._removeItem(`preKey${keyId}`); }

            // Signed PreKeys
            getSignedPreKey(keyId) { return this._getItem(`signedPreKey${keyId}`); }
            storeSignedPreKey(keyId, keyPair) { return this._setItem(`signedPreKey${keyId}`, keyPair); }
            removeSignedPreKey(keyId) { return this._removeItem(`signedPreKey${keyId}`); }

            // Sessions
            loadSession(identifier) { return this._getItem(`session${identifier}`); }
            storeSession(identifier, record) { return this._setItem(`session${identifier}`, record); }

            // Registration ID
            getRegistrationId() { return this._getItem('registrationId'); }
            setRegistrationId(registrationId) { return this._setItem('registrationId', registrationId); }

            // Verified Identity Keys for MITM protection
            saveVerifiedIdentityKey(address, identityKey) {
                const key = `${address.getName()}.${address.getDeviceId()}`;
                this.verifiedIdentityKeys.set(key, identityKey);
                this._setItem(`verifiedIdentity_${key}`, identityKey);
            }

            isIdentityVerified(address, identityKey) {
                const key = `${address.getName()}.${address.getDeviceId()}`;
                const savedKey = this.verifiedIdentityKeys.get(key) || this._getItem(`verifiedIdentity_${key}`);
                if (!savedKey) return false;
                
                // Compare identity keys
                return arrayBufferToBase64(savedKey) === arrayBufferToBase64(identityKey);
            }

            // Session safety checks
            isSessionValid(address) {
                const session = this.loadSession(address.toString());
                if (!session) return false;
                
                // Check if session has proper ratchet state
                return session.currentRatchet && session.currentRatchet.ephemeralKeyPair;
            }

            // Internal methods
            _getItem(key) { return this._store[key]; }
            _setItem(key, value) { this._store[key] = value; }
            _removeItem(key) { delete this._store[key]; }

            // Serialization for storage
            toObject() {
                return {
                    store: this._store,
                    verifiedIdentityKeys: Array.from(this.verifiedIdentityKeys.entries())
                };
            }

            fromObject(obj) {
                this._store = obj.store || {};
                this.verifiedIdentityKeys = new Map(obj.verifiedIdentityKeys || []);
            }
        }

        // ==================== SECURITY STATE ====================
        let currentUser = null;
        let userDisplayName = '';
        let signalStore = new SignalProtocolStore();
        let verifiedUsers = new Map(); // userId -> {publicKey, securityCode, verifiedAt}
        let messageCache = new Map(); // messageId -> timestamp (for replay protection)

        // ==================== KEY MANAGEMENT ====================

        async function generateAndRegisterKeys(userIdentifier, store) {
            // Generate a registration ID
            const registrationId = libsignal.KeyHelper.generateRegistrationId();
            store.setRegistrationId(registrationId);

            // Generate Identity Key Pair (X25519)
            const identityKeyPair = await libsignal.KeyHelper.generateIdentityKeyPair();
            store.setIdentityKeyPair(identityKeyPair);

            // Generate a Signed PreKey (X25519)
            const signedPreKeyId = 1;
            const signedPreKey = await libsignal.KeyHelper.generateSignedPreKey(identityKeyPair, signedPreKeyId);
            store.storeSignedPreKey(signedPreKeyId, signedPreKey.keyPair);

            // Generate a batch of One-Time PreKeys (X25519)
            const oneTimePreKeys = [];
            for (let i = 0; i < SECURITY_CONFIG.PRE_KEY_AMOUNT; ++i) {
                const preKeyId = i + 1;
                const preKey = await libsignal.KeyHelper.generatePreKey(preKeyId);
                store.storePreKey(preKeyId, preKey.keyPair);
                
                // Prepare the public key for the server bundle
                const publicPreKey = {
                    keyId: preKey.keyId,
                    publicKey: preKey.keyPair.pubKey
                };
                oneTimePreKeys.push(publicPreKey);
            }

            // Create the public bundle for the server
            const publicSignedPreKey = {
                keyId: signedPreKeyId,
                publicKey: signedPreKey.keyPair.pubKey,
                signature: signedPreKey.signature
            };

            const userKeyBundle = {
                registrationId: registrationId,
                identityPubKey: identityKeyPair.pubKey,
                signedPreKey: publicSignedPreKey,
                oneTimePreKeys: oneTimePreKeys
            };

            // Store in Firestore
            const userRef = db.collection('users').doc(userIdentifier);
            await userRef.set({
                keyBundle: userKeyBundle,
                displayName: userDisplayName,
                securityCode: await generateSecurityCode(identityKeyPair.pubKey),
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                lastSeen: firebase.firestore.FieldValue.serverTimestamp()
            }, { merge: true });

            console.log('Signal Protocol keys generated and bundle uploaded to server.');
            return userKeyBundle;
        }

        // ==================== FIX #1: VERIFY IDENTITY KEY BEFORE FIRST MESSAGE ====================

        async function verifyRecipientBundleBeforeSession(recipientId, recipientBundle) {
            // Check if we have a verified security code for this user
            const verifiedUser = verifiedUsers.get(recipientId);
            if (!verifiedUser) {
                throw new Error(`Security alert: User ${recipientId} is not verified. Please verify their security code before messaging.`);
            }

            // Calculate the expected security code from the received bundle
            const computedCode = await generateSecurityCode(recipientBundle.identityPubKey);
            
            // Compare with our saved verified code
            if (computedCode !== verifiedUser.securityCode) {
                throw new Error(`SECURITY ALERT: Identity key mismatch for ${recipientId}. Possible MITM attack! Expected: ${verifiedUser.securityCode}, Got: ${computedCode}`);
            }

            console.log(`‚úÖ Identity key verified for ${recipientId}`);
            return true;
        }

        async function startSessionAndSendMessage(recipientId, messageText, store) {
            try {
                // Fetch the recipient's key bundle from Firestore
                const recipientDoc = await db.collection('users').doc(recipientId).get();
                if (!recipientDoc.exists) {
                    throw new Error('Recipient not found');
                }

                const recipientBundle = recipientDoc.data().keyBundle;
                if (!recipientBundle) {
                    throw new Error('Recipient has no key bundle');
                }

                // CRITICAL FIX: Verify identity key before starting session
                await verifyRecipientBundleBeforeSession(recipientId, recipientBundle);

                // Create an address object for the recipient
                const recipientAddress = new libsignal.SignalProtocolAddress(recipientId, 1);

                // Build a session with the recipient's bundle
                const sessionBuilder = new libsignal.SessionBuilder(store, recipientAddress);
                await sessionBuilder.processPreKey(recipientBundle);

                // Save the verified identity key for future message verification
                store.saveVerifiedIdentityKey(recipientAddress, recipientBundle.identityPubKey);

                // Encrypt the message
                const sessionCipher = new libsignal.SessionCipher(store, recipientAddress);
                const plaintext = new TextEncoder().encode(messageText).buffer;
                const ciphertext = await sessionCipher.encrypt(plaintext);

                return {
                    recipientId: recipientId,
                    ciphertext: ciphertext,
                    type: ciphertext.type,
                    sessionValid: true
                };
            } catch (error) {
                console.error('Failed to start session and send message:', error);
                throw error;
            }
        }

        async function sendMessageToRecipient(recipientId, messageText, store) {
            const recipientAddress = new libsignal.SignalProtocolAddress(recipientId, 1);
            const sessionCipher = new libsignal.SessionCipher(store, recipientAddress);
            const plaintext = new TextEncoder().encode(messageText).buffer;
            const ciphertext = await sessionCipher.encrypt(plaintext);
            
            return {
                recipientId: recipientId,
                ciphertext: ciphertext,
                type: ciphertext.type,
                sessionValid: store.isSessionValid(recipientAddress)
            };
        }

        // ==================== FIX #2: SENDER AUTHENTICATION & SESSION VERIFICATION ====================

        async function receiveAndDecryptMessage(senderId, ciphertextMessage, store) {
            try {
                const senderAddress = new libsignal.SignalProtocolAddress(senderId, 1);
                const sessionCipher = new libsignal.SessionCipher(store, senderAddress);

                let plaintextArrayBuffer;
                let sessionSafety = {
                    hasValidSession: store.isSessionValid(senderAddress),
                    identityVerified: false,
                    decryptionSuccess: false
                };

                // Check the message type to use the correct decryption method
                if (ciphertextMessage.type === 3) {
                    // PreKeyWhisperMessage (first message) - establishes new session
                    plaintextArrayBuffer = await sessionCipher.decryptPreKeyWhisperMessage(ciphertextMessage.body, 'binary');
                    sessionSafety.decryptionSuccess = true;
                    
                    // After first message decryption, verify the identity key from the session
                    const session = store.loadSession(senderAddress.toString());
                    if (session && session.remoteIdentityKey) {
                        sessionSafety.identityVerified = store.isIdentityVerified(senderAddress, session.remoteIdentityKey);
                        if (!sessionSafety.identityVerified) {
                            console.warn(`‚ö†Ô∏è First message from ${senderId} - identity not yet verified`);
                        }
                    }
                } else if (ciphertextMessage.type === 1) {
                    // WhisperMessage (subsequent message) - uses existing session
                    plaintextArrayBuffer = await sessionCipher.decryptWhisperMessage(ciphertextMessage.body, 'binary');
                    sessionSafety.decryptionSuccess = true;
                    
                    // For subsequent messages, check session validity and identity verification
                    sessionSafety.hasValidSession = store.isSessionValid(senderAddress);
                    const session = store.loadSession(senderAddress.toString());
                    if (session && session.remoteIdentityKey) {
                        sessionSafety.identityVerified = store.isIdentityVerified(senderAddress, session.remoteIdentityKey);
                    }
                } else {
                    throw new Error('Unknown message type: ' + ciphertextMessage.type);
                }

                // Convert the decrypted ArrayBuffer back to a string
                const plaintext = new TextDecoder().decode(new Uint8Array(plaintextArrayBuffer));
                
                return {
                    plaintext: plaintext,
                    sessionSafety: sessionSafety
                };
            } catch (error) {
                console.error('Failed to decrypt message:', error);
                throw error;
            }
        }

        function getMessageVerificationStatus(sessionSafety, senderId) {
            const verifiedUser = verifiedUsers.get(senderId);
            
            // Highest priority: Decryption failed or no valid session
            if (!sessionSafety.decryptionSuccess) {
                return {
                    level: 'error',
                    text: 'üî¥ Decryption failed',
                    description: 'Message could not be decrypted'
                };
            }

            // Medium priority: Valid session but identity not verified
            if (sessionSafety.hasValidSession && sessionSafety.identityVerified) {
                return {
                    level: 'verified',
                    text: '‚úÖ Verified contact',
                    description: 'Encrypted and authenticated via secure session'
                };
            }

            // Check if user is in verified users list (out-of-band verification)
            if (verifiedUser) {
                return {
                    level: 'verified',
                    text: '‚úÖ Verified contact',
                    description: 'Security code verified'
                };
            }

            // Lowest priority: Valid decryption but unverified identity
            if (sessionSafety.decryptionSuccess) {
                return {
                    level: 'unverified',
                    text: '‚ö†Ô∏è Unverified contact',
                    description: 'Message decrypted but sender identity not verified'
                };
            }

            return {
                level: 'unknown',
                text: '‚ùì Unknown security status',
                description: 'Unable to verify message authenticity'
            };
        }

        // ==================== KEY WRAPPING AND STORAGE ====================

        async function wrapStore(store, passphrase) {
            const storeObj = store.toObject();
            const storeString = JSON.stringify(storeObj);
            
            // Generate salt and derive wrapping key
            const salt = window.crypto.getRandomValues(new Uint8Array(SECURITY_CONFIG.SALT_LENGTH));
            const wrappingKey = await deriveWrappingKey(passphrase, salt);
            
            // Generate IV and encrypt
            const iv = window.crypto.getRandomValues(new Uint8Array(SECURITY_CONFIG.MESSAGE_IV_LENGTH));
            const ciphertext = await window.crypto.subtle.encrypt(
                { 
                    name: SECURITY_CONFIG.KEY_WRAPPING_ALGORITHM, 
                    iv: iv 
                },
                wrappingKey,
                new TextEncoder().encode(storeString)
            );

            return {
                ciphertext: arrayBufferToBase64(ciphertext),
                iv: arrayBufferToBase64(iv),
                salt: arrayBufferToBase64(salt),
                iterations: SECURITY_CONFIG.PBKDF2_ITERATIONS,
                version: 1
            };
        }

        async function unwrapStore(wrappedBundle, passphrase) {
            try {
                const wrappingKey = await deriveWrappingKey(passphrase, base64ToArrayBuffer(wrappedBundle.salt));
                const ciphertext = base64ToArrayBuffer(wrappedBundle.ciphertext);
                const iv = base64ToArrayBuffer(wrappedBundle.iv);
                
                const decrypted = await window.crypto.subtle.decrypt(
                    { 
                        name: SECURITY_CONFIG.KEY_WRAPPING_ALGORITHM, 
                        iv: iv 
                    },
                    wrappingKey,
                    ciphertext
                );

                const storeString = new TextDecoder().decode(decrypted);
                return JSON.parse(storeString);
            } catch (error) {
                throw new Error('Failed to unwrap store: ' + error.message);
            }
        }

        // ==================== SECURITY UTILITIES ====================

        async function generateSecurityCode(publicKey) {
            const hash = await window.crypto.subtle.digest(
                'SHA-256', 
                new TextEncoder().encode(arrayBufferToBase64(publicKey))
            );
            const hashArray = Array.from(new Uint8Array(hash));
            // Take first 12 bytes (24 hex chars) for readable code
            return hashArray.slice(0, 12).map(b => b.toString(16).padStart(2, '0')).join('').toUpperCase();
        }

        async function deriveWrappingKey(passphrase, salt) {
            const enc = new TextEncoder();
            const pass = enc.encode(passphrase);
            const keyMaterial = await window.crypto.subtle.importKey(
                "raw", pass, { name: "PBKDF2" }, false, ["deriveKey"]
            );
            
            return await window.crypto.subtle.deriveKey(
                {
                    name: "PBKDF2",
                    salt: salt,
                    iterations: SECURITY_CONFIG.PBKDF2_ITERATIONS,
                    hash: "SHA-256"
                },
                keyMaterial,
                { name: "AES-GCM", length: SECURITY_CONFIG.KEY_LENGTH },
                false,
                ["encrypt", "decrypt"]
            );
        }

        function generateMessageId() {
            return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        }

        function isReplayAttack(messageId, timestamp) {
            // Check if message is too old
            if (Date.now() - timestamp > SECURITY_CONFIG.MAX_MESSAGE_AGE) {
                return true;
            }

            // Check if we've seen this message ID before
            if (messageCache.has(messageId)) {
                return true;
            }

            // Add to cache and clean old entries
            messageCache.set(messageId, timestamp);
            if (messageCache.size > SECURITY_CONFIG.MAX_CACHED_MESSAGES) {
                const oldestEntries = Array.from(messageCache.entries())
                    .sort((a, b) => a[1] - b[1])
                    .slice(0, messageCache.size - SECURITY_CONFIG.MAX_CACHED_MESSAGES);
                oldestEntries.forEach(([id]) => messageCache.delete(id));
            }

            return false;
        }

        // ==================== UTILITY FUNCTIONS ====================

        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        function base64ToArrayBuffer(base64) {
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // ==================== STORAGE MANAGEMENT ====================

        async function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('SecureChatSignalStore', 4);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('signalStore')) {
                        db.createObjectStore('signalStore', { keyPath: 'id' });
                    }
                };
            });
        }

        async function storeWrappedKeys(wrappedBundle) {
            try {
                const db = await openDB();
                const tx = db.transaction('signalStore', 'readwrite');
                await tx.objectStore('signalStore').put({
                    id: 'signalStore',
                    ...wrappedBundle,
                    createdAt: Date.now()
                });
            } catch (error) {
                console.error('Error storing wrapped keys:', error);
                throw error;
            }
        }

        async function loadWrappedKeys() {
            try {
                const db = await openDB();
                const tx = db.transaction('signalStore', 'readonly');
                const wrappedBundle = await tx.objectStore('signalStore').get('signalStore');
                return wrappedBundle || null;
            } catch (error) {
                console.error('Error loading wrapped keys:', error);
                return null;
            }
        }

        // ==================== VERIFICATION MANAGEMENT ====================

        async function initializeKeyVerification() {
            const identityKeyPair = signalStore.getIdentityKeyPair();
            if (!identityKeyPair) {
                throw new Error('No identity key pair found');
            }
            
            const securityCode = await generateSecurityCode(identityKeyPair.pubKey);
            
            // Store our own key for consistency
            verifiedUsers.set(currentUser.uid, {
                publicKey: identityKeyPair.pubKey,
                securityCode: securityCode,
                verifiedAt: Date.now(),
                isCurrentUser: true
            });

            // Load existing verified users
            await loadVerifiedUsers();
            
            return securityCode;
        }

        async function loadVerifiedUsers() {
            try {
                const stored = localStorage.getItem(`verifiedUsers_${currentUser.uid}`);
                if (stored) {
                    const parsed = JSON.parse(stored);
                    parsed.forEach(([userId, data]) => {
                        verifiedUsers.set(userId, data);
                    });
                }
            } catch (error) {
                console.error('Failed to load verified users:', error);
            }
        }

        async function saveVerifiedUsers() {
            try {
                const data = Array.from(verifiedUsers.entries());
                localStorage.setItem(`verifiedUsers_${currentUser.uid}`, JSON.stringify(data));
            } catch (error) {
                console.error('Failed to save verified users:', error);
            }
        }

        async function verifyUserSecurityCode(userId, securityCode) {
            const userDoc = await db.collection('users').doc(userId).get();
            if (!userDoc.exists) return false;

            const userData = userDoc.data();
            if (!userData.keyBundle) return false;

            const computedCode = await generateSecurityCode(userData.keyBundle.identityPubKey);
            
            if (computedCode === securityCode) {
                verifiedUsers.set(userId, {
                    publicKey: userData.keyBundle.identityPubKey,
                    securityCode: computedCode,
                    verifiedAt: Date.now()
                });
                await saveVerifiedUsers();
                return true;
            }
            
            return false;
        }

        // ==================== UI MANAGEMENT ====================

        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(screenId).classList.add('active');
        }

        function showError(elementId, message) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.style.display = 'block';
        }

        function hideError(elementId) {
            const element = document.getElementById(elementId);
            element.style.display = 'none';
        }

        // ==================== FIREBASE AUTH ====================

        async function signUp() {
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            
            try {
                hideError('auth-error');
                const userCredential = await auth.createUserWithEmailAndPassword(email, password);
                currentUser = userCredential.user;
                userDisplayName = email.split('@')[0];
                showScreen('passphrase-screen');
            } catch (error) {
                showError('auth-error', error.message);
            }
        }

        async function signIn() {
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            
            try {
                hideError('auth-error');
                const userCredential = await auth.signInWithEmailAndPassword(email, password);
                currentUser = userCredential.user;
                
                const wrappedKeys = await loadWrappedKeys();
                if (wrappedKeys) {
                    showScreen('unlock-screen');
                } else {
                    userDisplayName = email.split('@')[0];
                    showScreen('passphrase-screen');
                }
            } catch (error) {
                showError('auth-error', error.message);
            }
        }

        // ==================== EVENT LISTENERS ====================

        document.addEventListener('DOMContentLoaded', function() {
            // Auth event listeners
            document.getElementById('signup-btn').addEventListener('click', signUp);
            document.getElementById('signin-btn').addEventListener('click', signIn);
            
            // Passphrase setup
            document.getElementById('setup-encryption-btn').addEventListener('click', setupEncryption);
            
            // Unlock
            document.getElementById('unlock-btn').addEventListener('click', handleUnlock);
            
            // Verification
            document.getElementById('complete-verification-btn').addEventListener('click', completeVerification);
            document.getElementById('skip-verification-btn').addEventListener('click', () => showScreen('chat-screen'));
            
            // Security modal
            document.getElementById('security-info-btn').addEventListener('click', showSecurityInfo);
            document.getElementById('close-security-modal').addEventListener('click', closeSecurityModal);
            
            // Logout
            document.getElementById('logout-btn').addEventListener('click', signOut);
            
            // Message input
            document.getElementById('send-btn').addEventListener('click', sendMessage);
            document.getElementById('message-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });

            // Auth state listener
            auth.onAuthStateChanged((user) => {
                if (!user) {
                    showScreen('auth-screen');
                }
            });

            // Set up message listener
            setupMessageListener();
        });

        async function setupEncryption() {
            const passphrase = document.getElementById('passphrase').value;
            const confirmPassphrase = document.getElementById('passphrase-confirm').value;
            
            if (!passphrase || passphrase.length < 8) {
                alert('Passphrase must be at least 8 characters long');
                return;
            }
            
            if (passphrase !== confirmPassphrase) {
                alert('Passphrases do not match');
                return;
            }

            try {
                document.getElementById('setup-encryption-btn').disabled = true;
                document.getElementById('setup-encryption-btn').textContent = 'Generating keys...';

                // Generate Signal Protocol keys and register with server
                await generateAndRegisterKeys(currentUser.uid, signalStore);

                // Wrap and store the entire signal store
                const wrappedBundle = await wrapStore(signalStore, passphrase);
                await storeWrappedKeys(wrappedBundle);

                // Initialize key verification
                const securityCode = await initializeKeyVerification();
                
                // Show verification screen with security code
                document.getElementById('user-security-code').textContent = securityCode;
                
                // Generate QR code
                QRCode.toCanvas(document.getElementById('qr-code-container'), securityCode, function (error) {
                    if (error) console.error('QR code generation error:', error);
                });

                showScreen('verification-screen');

            } catch (error) {
                console.error('Encryption setup failed:', error);
                alert('Error setting up encryption: ' + error.message);
                document.getElementById('setup-encryption-btn').disabled = false;
                document.getElementById('setup-encryption-btn').textContent = 'Setup Encryption';
            }
        }

        async function handleUnlock() {
            const passphrase = document.getElementById('unlock-passphrase').value;
            
            if (!passphrase) {
                showError('unlock-error', 'Please enter your passphrase');
                return;
            }

            try {
                document.getElementById('unlock-btn').disabled = true;
                document.getElementById('unlock-btn').textContent = 'Unlocking...';

                const wrappedBundle = await loadWrappedKeys();
                if (!wrappedBundle) {
                    throw new Error('No encrypted keys found');
                }

                const storeObj = await unwrapStore(wrappedBundle, passphrase);
                signalStore.fromObject(storeObj);

                await initializeKeyVerification();
                showScreen('chat-screen');

            } catch (error) {
                showError('unlock-error', 'Invalid passphrase or corrupted keys');
                document.getElementById('unlock-btn').disabled = false;
                document.getElementById('unlock-btn').textContent = 'Unlock';
            }
        }

        async function completeVerification() {
            const checkboxes = document.querySelectorAll('.verify-checkbox:checked');
            for (const checkbox of checkboxes) {
                await verifyUserSecurityCode(checkbox.dataset.userid, checkbox.dataset.securitycode);
            }
            
            await saveVerifiedUsers();
            showScreen('chat-screen');
        }

        function showSecurityInfo() {
            // Implementation for security info modal
            document.getElementById('security-modal').classList.add('active');
        }

        function closeSecurityModal() {
            document.getElementById('security-modal').classList.remove('active');
        }

        async function signOut() {
            try {
                await auth.signOut();
                showScreen('auth-screen');
            } catch (error) {
                console.error('Sign out error:', error);
            }
        }

        // ==================== MESSAGE HANDLING ====================

        async function sendMessage() {
            const messageInput = document.getElementById('message-input');
            const messageText = messageInput.value.trim();
            
            if (!messageText || !currentUser) return;

            try {
                const messageId = generateMessageId();
                
                // Get all users to encrypt for
                const usersSnapshot = await db.collection('users').get();
                const encryptedMessages = [];

                for (const userDoc of usersSnapshot.docs) {
                    if (userDoc.id === currentUser.uid) continue; // Skip self

                    try {
                        let encryptedResult;
                        
                        // Check if we already have a session with this user
                        const recipientAddress = new libsignal.SignalProtocolAddress(userDoc.id, 1);
                        const sessionCipher = new libsignal.SessionCipher(signalStore, recipientAddress);
                        
                        // Try to encrypt (this will work if we have a session)
                        const plaintext = new TextEncoder().encode(messageText).buffer;
                        encryptedResult = await sessionCipher.encrypt(plaintext);
                        
                        encryptedMessages.push({
                            userId: userDoc.id,
                            encryptedMessage: JSON.stringify({
                                type: encryptedResult.type,
                                body: arrayBufferToBase64(encryptedResult.body)
                            })
                        });
                    } catch (sessionError) {
                        // If encryption fails, we need to start a new session
                        try {
                            // CRITICAL FIX: This will now verify identity key before session
                            encryptedResult = await startSessionAndSendMessage(userDoc.id, messageText, signalStore);
                            encryptedMessages.push({
                                userId: userDoc.id,
                                encryptedMessage: JSON.stringify({
                                    type: encryptedResult.ciphertext.type,
                                    body: arrayBufferToBase64(encryptedResult.ciphertext.body)
                                })
                            });
                        } catch (startSessionError) {
                            console.error(`Failed to start session with ${userDoc.id}:`, startSessionError);
                            // Show security warning to user
                            displaySecurityWarning(`Cannot send to ${userDoc.data().displayName}: ${startSessionError.message}`);
                        }
                    }
                }

                // Store encrypted message in Firestore
                if (encryptedMessages.length > 0) {
                    await db.collection('messages').add({
                        encryptedMessages: encryptedMessages,
                        senderId: currentUser.uid,
                        senderName: userDisplayName,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        messageId: messageId,
                        type: 'text'
                    });
                }

                // Also display the message locally
                displayMessage(messageText, currentUser.uid, true, { level: 'verified', text: '‚úÖ Sent securely' });
                messageInput.value = '';
                document.getElementById('char-count').textContent = '0';

            } catch (error) {
                console.error('Failed to send message:', error);
                alert('Error sending message: ' + error.message);
            }
        }

        function setupMessageListener() {
            db.collection('messages')
                .orderBy('timestamp', 'asc')
                .onSnapshot(async (snapshot) => {
                    for (const change of snapshot.docChanges()) {
                        if (change.type === 'added') {
                            const message = change.doc.data();
                            
                            // Find the encrypted message for current user
                            const userMessage = message.encryptedMessages.find(msg => msg.userId === currentUser.uid);
                            if (userMessage) {
                                try {
                                    const ciphertext = JSON.parse(userMessage.encryptedMessage);
                                    const ciphertextMessage = {
                                        type: ciphertext.type,
                                        body: base64ToArrayBuffer(ciphertext.body)
                                    };
                                    
                                    const decryptionResult = await receiveAndDecryptMessage(message.senderId, ciphertextMessage, signalStore);
                                    
                                    // Check for replay attacks
                                    if (!isReplayAttack(message.messageId, message.timestamp.toMillis())) {
                                        const verificationStatus = getMessageVerificationStatus(
                                            decryptionResult.sessionSafety, 
                                            message.senderId
                                        );
                                        displayMessage(decryptionResult.plaintext, message.senderId, false, verificationStatus);
                                    }
                                } catch (error) {
                                    console.error('Failed to decrypt message:', error);
                                    displayMessage('üîí [Encrypted message - decryption failed]', message.senderId, false, {
                                        level: 'error',
                                        text: 'üî¥ Decryption failed',
                                        description: error.message
                                    });
                                }
                            }
                        }
                    }
                });
        }

        function displayMessage(text, senderId, isSent, verificationStatus) {
            const messagesContainer = document.getElementById('messages-container');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isSent ? 'sent' : 'received'}`;
            
            const messageContent = document.createElement('div');
            messageContent.textContent = text;
            messageDiv.appendChild(messageContent);

            // Add security indicator based on verification status
            const securityDiv = document.createElement('div');
            securityDiv.className = `message-${verificationStatus.level}`;
            securityDiv.textContent = verificationStatus.text;
            
            // Add tooltip for detailed security information
            securityDiv.title = verificationStatus.description;
            messageDiv.appendChild(securityDiv);

            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function displaySecurityWarning(message) {
            const messagesContainer = document.getElementById('messages-container');
            const warningDiv = document.createElement('div');
            warningDiv.className = 'security-indicator security-warning';
            warningDiv.textContent = `‚ö†Ô∏è SECURITY WARNING: ${message}`;
            messagesContainer.appendChild(warningDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

    </script>
</body>
</html>
