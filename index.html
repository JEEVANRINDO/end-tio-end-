<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure Private Chat</title>
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-storage-compat.js"></script>
    
    <style>
        *{margin:0;padding:0;box-sizing:border-box;}
        :root{--whatsapp-green:#25D366;--whatsapp-dark:#075E54;--whatsapp-light:#128C7E;--chat-bg:#e5ddd5;--message-sent:#dcf8c6;--message-received:#ffffff;--border-color:#e0e0e0;--error-color:#e74c3c;--warning-color:#f39c12;}
        body{font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;background:var(--chat-bg);height:100vh;overflow:hidden;}
        .screen{display:none;height:100vh;width:100%;}
        .screen.active{display:flex;flex-direction:column;}
        #auth-screen{background:linear-gradient(135deg,var(--whatsapp-dark)0%,var(--whatsapp-light)100%);justify-content:center;align-items:center;}
        .auth-container{background:white;padding:2.5rem;border-radius:16px;box-shadow:0 20px 40px rgba(0,0,0,0.1);width:90%;max-width:400px;text-align:center;}
        .auth-form input{width:100%;padding:14px;margin:10px 0;border:2px solid var(--border-color);border-radius:8px;font-size:16px;}
        .auth-buttons button{width:100%;padding:14px;margin:8px 0;border:none;border-radius:8px;font-size:16px;font-weight:600;cursor:pointer;}
        #signup-btn{background:var(--whatsapp-green);color:white;}
        #signin-btn{background:var(--whatsapp-dark);color:white;}
        .security-indicator{display:flex;align-items:center;gap:8px;padding:8px 12px;background:#e8f5e8;border-radius:8px;margin:10px 0;font-size:0.8rem;color:#2e7d32;}
        .security-warning{background:#ffebee;color:#c62828;}
        .key-management{background:#f3e5f5;border-radius:8px;padding:1rem;margin:1rem 0;}
        .key-fingerprint{font-family:monospace;word-break:break-all;background:white;padding:8px;border-radius:4px;margin:8px 0;font-size:0.7rem;}
        .verification-section{border:2px solid #4caf50;border-radius:8px;padding:1rem;margin:1rem 0;background:#f1f8e9;}
        .device-list{margin:1rem 0;}
        .device-item{padding:0.5rem;border:1px solid #ddd;border-radius:4px;margin:0.5rem 0;background:white;}
        .verified-badge{color:#4caf50;font-weight:bold;}
        .warning-badge{color:#ff9800;font-weight:bold;}
        .passphrase-input{width:100%;padding:12px;margin:8px 0;border:2px solid var(--border-color);border-radius:8px;}
        .message-verified{color:#4caf50;font-size:0.7rem;}
        .message-unverified{color:#ff9800;font-size:0.7rem;}
        .message-security-error{color:#f44336;font-size:0.7rem;}
        .qr-code{width:200px;height:200px;margin:1rem auto;border:2px solid #ddd;border-radius:8px;padding:10px;background:white;}
        .ratchet-status{font-size:0.7rem;color:#666;margin-top:4px;}
        #chat-screen{background:var(--chat-bg);}
        .chat-header{background:var(--whatsapp-dark);color:white;padding:1rem 1.5rem;display:flex;justify-content:space-between;align-items:center;}
        .chat-container{flex:1;display:flex;flex-direction:column;max-width:1200px;margin:0 auto;width:100%;height:calc(100vh - 80px);}
        .messages-container{flex:1;padding:1rem;overflow-y:auto;background:var(--chat-bg);}
        .message{margin:8px 0;padding:12px 16px;border-radius:8px;max-width:70%;word-wrap:break-word;animation:fadeIn 0.3s ease-in;}
        .message.sent{background:var(--message-sent);margin-left:auto;}
        .message.received{background:var(--message-received);box-shadow:0 1px 2px rgba(0,0,0,0.1);}
        .message-input-container{background:white;border-top:1px solid var(--border-color);padding:1rem;}
        .message-input{display:flex;gap:12px;align-items:center;}
        .message-input input{flex:1;padding:12px 18px;border:2px solid var(--border-color);border-radius:24px;outline:none;font-size:15px;}
        .modal{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);justify-content:center;align-items:center;z-index:1000;}
        .modal.active{display:flex;}
        .modal-content{background:white;padding:2rem;border-radius:12px;width:90%;max-width:500px;max-height:90vh;overflow-y:auto;}
        .error-message{color:var(--error-color);margin-top:1rem;}
        .hidden{display:none;}
        .text-center{text-align:center;}
        .mt-2{margin-top:1rem;}
        .mb-2{margin-bottom:1rem;}
        @keyframes fadeIn{from{opacity:0;transform:translateY(10px);}to{opacity:1;transform:translateY(0);}}
    </style>
</head>
<body>
    <div id="auth-screen" class="screen active">
        <div class="auth-container">
            <div class="app-logo">
                <h1>üîí Secure Private Chat</h1>
                <p>Military Grade End-to-End Encryption</p>
            </div>
            <div class="auth-form">
                <input type="email" id="email" placeholder="Email address" value="test@example.com">
                <input type="password" id="password" placeholder="Password" value="123456">
                <div class="auth-buttons">
                    <button id="signup-btn">Create Account</button>
                    <button id="signin-btn">Sign In</button>
                </div>
            </div>
            <div id="auth-error" class="error-message"></div>
        </div>
    </div>

    <div id="passphrase-screen" class="screen">
        <div class="auth-container">
            <h2>üîê Set Encryption Passphrase</h2>
            <p>This passphrase protects your encryption keys. You'll need it to access your messages.</p>
            <div class="key-management">
                <input type="password" id="passphrase" class="passphrase-input" placeholder="Enter a strong passphrase">
                <input type="password" id="passphrase-confirm" class="passphrase-input" placeholder="Confirm passphrase">
                <div class="security-indicator">
                    <span>üîí</span>
                    <span>Your passphrase is never sent to the server</span>
                </div>
                <button id="setup-encryption-btn">Setup Encryption</button>
            </div>
        </div>
    </div>

    <div id="unlock-screen" class="screen">
        <div class="auth-container">
            <h2>üîê Unlock Encryption</h2>
            <p>Enter your passphrase to decrypt your messages</p>
            <div class="key-management">
                <input type="password" id="unlock-passphrase" class="passphrase-input" placeholder="Enter your passphrase">
                <div id="unlock-error" class="error-message"></div>
                <button id="unlock-btn">Unlock</button>
                <div class="security-indicator">
                    <span>üîÑ</span>
                    <span><a href="#" id="reset-encryption-link">Reset encryption keys</a> (will lose access to old messages)</span>
                </div>
            </div>
        </div>
    </div>

    <div id="verification-screen" class="screen">
        <div class="auth-container">
            <h2>üîç Verify Security Codes</h2>
            <p>Compare security codes with other users to prevent MITM attacks</p>
            <div class="verification-section">
                <h4>Your Security Code:</h4>
                <div class="key-fingerprint" id="user-security-code"></div>
                <div class="qr-code" id="qr-code-container"></div>
                <h4>Other Users to Verify:</h4>
                <div id="users-to-verify-list"></div>
            </div>
            <button id="complete-verification-btn">I've Verified Security Codes</button>
            <button id="skip-verification-btn" class="mt-2" style="background:#666;">Skip for Now</button>
        </div>
    </div>

    <div id="device-approval-screen" class="screen">
        <div class="auth-container">
            <h2>üì± Device Management</h2>
            <p>Review and approve your devices cryptographically</p>
            <div class="key-management">
                <h4>Your Current Device:</h4>
                <div class="key-fingerprint" id="current-device-fingerprint"></div>
                <h4>Pending Device Approvals:</h4>
                <div id="pending-devices-list"></div>
                <button id="continue-to-chat-btn" class="hidden">Continue to Chat</button>
            </div>
        </div>
    </div>

    <div id="chat-screen" class="screen">
        <div class="chat-header">
            <div class="header-info">
                <h3>üîí Secure Group Chat</h3>
                <span id="online-count">‚óè 0 online</span>
            </div>
            <div class="header-actions">
                <span id="user-name"></span>
                <button id="security-info-btn">Security</button>
                <button id="logout-btn">Logout</button>
            </div>
        </div>
        <div class="chat-container">
            <div id="messages-container" class="messages-container">
                <div class="security-indicator">
                    <span>üîí</span>
                    <span><strong>MILITARY GRADE ENCRYPTION</strong> - All messages are end-to-end encrypted and verified</span>
                </div>
                <div class="welcome-message">
                    <p>Welcome to your secure chat! Start a conversation with end-to-end encryption.</p>
                </div>
            </div>
            <div class="message-input-container">
                <div class="message-input">
                    <input type="text" id="message-input" placeholder="Type a secure message..." maxlength="1000">
                    <div class="input-buttons">
                        <button id="file-btn">üìé</button>
                        <button id="send-btn">Send</button>
                    </div>
                </div>
                <div class="input-actions">
                    <span class="char-count"><span id="char-count">0</span>/1000</span>
                    <span class="encryption-status">üîí End-to-end encrypted</span>
                </div>
            </div>
        </div>
    </div>

    <div id="security-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üîí Security Information</h3>
                <button class="close-btn" id="close-security-modal">√ó</button>
            </div>
            <div class="security-info">
                <div class="security-indicator">
                    <span>‚úÖ</span>
                    <span><strong>Military Grade Security Active</strong></span>
                </div>
                <div class="key-management">
                    <h4>Encryption Status</h4>
                    <div id="security-status-list"></div>
                    <div class="ratchet-status" id="ratchet-status"></div>
                </div>
                <button id="verify-security-codes-btn" class="mt-2">Verify Security Codes</button>
                <button id="manage-devices-btn" class="mt-2">Manage Devices</button>
                <button id="backup-keys-btn" class="mt-2">Backup Encryption Keys</button>
                <button id="rotate-keys-btn" class="mt-2">Rotate Keys</button>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const firebaseConfig = {
            apiKey: "AIzaSyBCix7_qzRM8dSopBef0ORyFjvssjV32Lc",
            authDomain: "messaging-app-1bd04.firebaseapp.com",
            projectId: "messaging-app-1bd04",
            storageBucket: "messaging-app-1bd04.firebasestorage.app",
            messagingSenderId: "443693550918",
            appId: "1:443693550918:web:62cb22ffd4056014822947",
            measurementId: "G-P9EWYXGNV2"
        };
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        const storage = firebase.storage();

        let libsignal = null;
        let signalLibraryLoaded = false;

        // --- UPDATED LIBRARY LOADING LOGIC ---
        function loadSignalLibrary() {
            return new Promise((resolve, reject) => {
                if (typeof window.libsignal !== 'undefined') {
                    libsignal = window.libsignal;
                    signalLibraryLoaded = true;
                    console.log('Signal library already loaded');
                    resolve();
                    return;
                }

                // UPDATED CDN LINKS HERE
                const cdns = [
                    'https://cdn.jsdelivr.net/npm/libsignal-protocol-javascript@2.0.0/dist/libsignal-protocol.js',
                    'https://cdn.jsdelivr.net/gh/Signal-Android/libsignal-protocol-javascript/dist/libsignal-protocol.js',
                    'https://unpkg.com/libsignal-protocol-javascript@2.0.0/dist/libsignal-protocol.js'
                ];

                function tryCDN(index) {
                    if (index >= cdns.length) {
                        reject(new Error('All CDN attempts failed. Please check your internet connection or library availability.'));
                        return;
                    }

                    const script = document.createElement('script');
                    script.src = cdns[index];
                    script.onload = () => {
                        if (typeof window.libsignal !== 'undefined') {
                            libsignal = window.libsignal;
                            signalLibraryLoaded = true;
                            console.log('Signal library loaded from CDN ' + (index + 1));
                            resolve();
                        } else {
                            // Loaded but object not found, try next
                            tryCDN(index + 1);
                        }
                    };
                    script.onerror = () => {
                        console.warn(`Failed to load CDN ${index + 1}, trying next...`);
                        tryCDN(index + 1);
                    };
                    document.head.appendChild(script);
                }

                tryCDN(0);
            });
        }

        const libraryLoadPromise = loadSignalLibrary();
        
        const SECURITY_CONFIG = {
            PBKDF2_ITERATIONS: 310000,
            KEY_WRAPPING_ALGORITHM: 'AES-GCM',
            KEY_LENGTH: 256,
            MESSAGE_IV_LENGTH: 12,
            SALT_LENGTH: 16,
            MAX_MESSAGE_AGE: 7 * 24 * 60 * 60 * 1000,
            MAX_CACHED_MESSAGES: 1000,
            PRE_KEY_AMOUNT: 100
        };

        class SignalProtocolStore {
            constructor() {
                this._store = {};
                this.verifiedIdentityKeys = new Map();
            }

            getIdentityKeyPair() { return this._getItem('identityKey'); }
            setIdentityKeyPair(keyPair) { return this._setItem('identityKey', keyPair); }
            getPreKey(keyId) { return this._getItem(`preKey${keyId}`); }
            storePreKey(keyId, keyPair) { return this._setItem(`preKey${keyId}`, keyPair); }
            removePreKey(keyId) { return this._removeItem(`preKey${keyId}`); }
            getSignedPreKey(keyId) { return this._getItem(`signedPreKey${keyId}`); }
            storeSignedPreKey(keyId, keyPair) { return this._setItem(`signedPreKey${keyId}`, keyPair); }
            removeSignedPreKey(keyId) { return this._removeItem(`signedPreKey${keyId}`); }
            loadSession(identifier) { return this._getItem(`session${identifier}`); }
            storeSession(identifier, record) { return this._setItem(`session${identifier}`, record); }
            getRegistrationId() { return this._getItem('registrationId'); }
            setRegistrationId(registrationId) { return this._setItem('registrationId', registrationId); }

            saveVerifiedIdentityKey(address, identityKey) {
                const key = `${address.getName()}.${address.getDeviceId()}`;
                this.verifiedIdentityKeys.set(key, identityKey);
                this._setItem(`verifiedIdentity_${key}`, identityKey);
            }

            isIdentityVerified(address, identityKey) {
                const key = `${address.getName()}.${address.getDeviceId()}`;
                const savedKey = this.verifiedIdentityKeys.get(key) || this._getItem(`verifiedIdentity_${key}`);
                if (!savedKey) return false;
                return arrayBufferToBase64(savedKey) === arrayBufferToBase64(identityKey);
            }

            isSessionValid(address) {
                const session = this.loadSession(address.toString());
                return !!(session && session.currentRatchet && session.currentRatchet.ephemeralKeyPair);
            }

            _getItem(key) { return this._store[key]; }
            _setItem(key, value) { this._store[key] = value; }
            _removeItem(key) { delete this._store[key]; }

            toObject() {
                return {
                    store: this._store,
                    verifiedIdentityKeys: Array.from(this.verifiedIdentityKeys.entries())
                };
            }

            fromObject(obj) {
                this._store = obj.store || {};
                this.verifiedIdentityKeys = new Map(obj.verifiedIdentityKeys || []);
            }
        }

        let currentUser = null;
        let userDisplayName = '';
        let signalStore = new SignalProtocolStore();
        let verifiedUsers = new Map();
        let messageCache = new Map();

        async function generateAndRegisterKeys(userIdentifier, store) {
            try {
                await libraryLoadPromise;
                if (!libsignal) {
                    throw new Error('Signal Protocol library failed to load');
                }

                const registrationId = libsignal.KeyHelper.generateRegistrationId();
                store.setRegistrationId(registrationId);

                const identityKeyPair = await libsignal.KeyHelper.generateIdentityKeyPair();
                store.setIdentityKeyPair(identityKeyPair);

                const signedPreKeyId = 1;
                const signedPreKey = await libsignal.KeyHelper.generateSignedPreKey(identityKeyPair, signedPreKeyId);
                store.storeSignedPreKey(signedPreKeyId, signedPreKey.keyPair);
                
                const oneTimePreKeys = [];
                for (let i = 0; i < SECURITY_CONFIG.PRE_KEY_AMOUNT; ++i) {
                    const preKeyId = i + 1;
                    const preKey = await libsignal.KeyHelper.generatePreKey(preKeyId);
                    store.storePreKey(preKeyId, preKey.keyPair);
                    const publicPreKey = {
                        keyId: preKey.keyId,
                        publicKey: preKey.keyPair.pubKey
                    };
                    oneTimePreKeys.push(publicPreKey);
                }

                const publicSignedPreKey = {
                    keyId: signedPreKeyId,
                    publicKey: signedPreKey.keyPair.pubKey,
                    signature: signedPreKey.signature
                };
                
                const userKeyBundle = {
                    registrationId: registrationId,
                    identityPubKey: identityKeyPair.pubKey,
                    signedPreKey: publicSignedPreKey,
                    oneTimePreKeys: oneTimePreKeys,
                    securityCode: await generateSecurityCode(identityKeyPair.pubKey)
                };
                
                const userRef = db.collection('users').doc(userIdentifier);
                await userRef.set({
                    keyBundle: userKeyBundle,
                    displayName: userDisplayName,
                    securityCode: userKeyBundle.securityCode,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    lastSeen: firebase.firestore.FieldValue.serverTimestamp(),
                    keyVersion: 1,
                    keyBundleUpdated: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true });
                return userKeyBundle;

            } catch (error) {
                throw new Error(`Failed to generate encryption keys: ${error.message}`);
            }
        }

        async function startSessionAndSendMessage(recipientId, messageText, store) {
            try {
                const recipientDoc = await db.collection('users').doc(recipientId).get();
                if (!recipientDoc.exists) throw new Error('Recipient not found');
                const recipientBundle = recipientDoc.data().keyBundle;
                if (!recipientBundle) throw new Error('Recipient has no key bundle');
                await verifyRecipientBundleBeforeSession(recipientId, recipientBundle);

                const recipientAddress = new libsignal.SignalProtocolAddress(recipientId, 1);
                const sessionBuilder = new libsignal.SessionBuilder(store, recipientAddress);
                await sessionBuilder.processPreKey(recipientBundle);

                store.saveVerifiedIdentityKey(recipientAddress, recipientBundle.identityPubKey);
                const sessionCipher = new libsignal.SessionCipher(store, recipientAddress);
                const plaintext = new TextEncoder().encode(messageText).buffer;
                const ciphertext = await sessionCipher.encrypt(plaintext);
                return {
                    recipientId: recipientId,
                    ciphertext: ciphertext,
                    type: ciphertext.type,
                    sessionValid: true
                };
            } catch (error) {
                throw error;
            }
        }

        async function verifyRecipientBundleBeforeSession(recipientId, recipientBundle) {
            const verifiedUser = verifiedUsers.get(recipientId);
            if (!verifiedUser) {
                // In a strict mode, we might block here. For now, we allow first contact but log it.
                // console.warn(`Note: User ${recipientId} is not manually verified yet.`);
                return true; 
            }

            const computedCode = await generateSecurityCode(recipientBundle.identityPubKey);
            if (computedCode !== verifiedUser.securityCode) throw new Error(`SECURITY ALERT: Identity key mismatch for ${recipientId}`);

            return true;
        }

        async function receiveAndDecryptMessage(senderId, ciphertextMessage, store) {
            try {
                const senderAddress = new libsignal.SignalProtocolAddress(senderId, 1);
                const sessionCipher = new libsignal.SessionCipher(store, senderAddress);

                let plaintextArrayBuffer;
                let sessionSafety = {
                    hasValidSession: store.isSessionValid(senderAddress),
                    identityVerified: false,
                    decryptionSuccess: false
                };
                
                if (ciphertextMessage.type === 3) {
                    plaintextArrayBuffer = await sessionCipher.decryptPreKeyWhisperMessage(ciphertextMessage.body, 'binary');
                    sessionSafety.decryptionSuccess = true;
                    const session = store.loadSession(senderAddress.toString());
                    if (session && session.remoteIdentityKey) sessionSafety.identityVerified = store.isIdentityVerified(senderAddress, session.remoteIdentityKey);
                } else if (ciphertextMessage.type === 1) {
                    plaintextArrayBuffer = await sessionCipher.decryptWhisperMessage(ciphertextMessage.body, 'binary');
                    sessionSafety.decryptionSuccess = true;
                    sessionSafety.hasValidSession = store.isSessionValid(senderAddress);
                    const session = store.loadSession(senderAddress.toString());
                    if (session && session.remoteIdentityKey) sessionSafety.identityVerified = store.isIdentityVerified(senderAddress, session.remoteIdentityKey);
                } else throw new Error('Unknown message type: ' + ciphertextMessage.type);

                const plaintext = new TextDecoder().decode(new Uint8Array(plaintextArrayBuffer));
                return { plaintext: plaintext, sessionSafety: sessionSafety };
            } catch (error) {
                throw error;
            }
        }

        async function generateSecurityCode(publicKey) {
            const hash = await window.crypto.subtle.digest('SHA-256', new TextEncoder().encode(arrayBufferToBase64(publicKey)));
            const hashArray = Array.from(new Uint8Array(hash));
            return hashArray.slice(0, 12).map(b => b.toString(16).padStart(2, '0')).join('').toUpperCase();
        }

        async function deriveWrappingKey(passphrase, salt) {
            const enc = new TextEncoder();
            const pass = enc.encode(passphrase);
            const keyMaterial = await window.crypto.subtle.importKey("raw", pass, { name: "PBKDF2" }, false, ["deriveKey"]);
            return await window.crypto.subtle.deriveKey({ name: "PBKDF2", salt: salt, iterations: SECURITY_CONFIG.PBKDF2_ITERATIONS, hash: "SHA-256" }, keyMaterial, { name: "AES-GCM", length: SECURITY_CONFIG.KEY_LENGTH }, false, ["encrypt", "decrypt"]);
        }

        async function wrapStore(store, passphrase) {
            const storeObj = store.toObject();
            const storeString = JSON.stringify(storeObj);
            const salt = window.crypto.getRandomValues(new Uint8Array(SECURITY_CONFIG.SALT_LENGTH));
            const wrappingKey = await deriveWrappingKey(passphrase, salt);
            const iv = window.crypto.getRandomValues(new Uint8Array(SECURITY_CONFIG.MESSAGE_IV_LENGTH));
            const ciphertext = await window.crypto.subtle.encrypt({ name: SECURITY_CONFIG.KEY_WRAPPING_ALGORITHM, iv: iv }, wrappingKey, new TextEncoder().encode(storeString));
            return { ciphertext: arrayBufferToBase64(ciphertext), iv: arrayBufferToBase64(iv), salt: arrayBufferToBase64(salt), iterations: SECURITY_CONFIG.PBKDF2_ITERATIONS, version: 1 };
        }

        async function unwrapStore(wrappedBundle, passphrase) {
            try {
                const wrappingKey = await deriveWrappingKey(passphrase, base64ToArrayBuffer(wrappedBundle.salt));
                const ciphertext = base64ToArrayBuffer(wrappedBundle.ciphertext);
                const iv = base64ToArrayBuffer(wrappedBundle.iv);
                const decrypted = await window.crypto.subtle.decrypt({ name: SECURITY_CONFIG.KEY_WRAPPING_ALGORITHM, iv: iv }, wrappingKey, ciphertext);
                const storeString = new TextDecoder().decode(decrypted);
                return JSON.parse(storeString);
            } catch (error) {
                throw new Error('Failed to unwrap store: ' + error.message);
            }
        }

        async function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('SecureChatSignalStore', 4);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('signalStore')) db.createObjectStore('signalStore', { keyPath: 'id' });
                };
            });
        }

        async function storeWrappedKeys(wrappedBundle) {
            try {
                const db = await openDB();
                const tx = db.transaction('signalStore', 'readwrite');
                await tx.objectStore('signalStore').put({ id: 'signalStore', ...wrappedBundle, createdAt: Date.now() });
            } catch (error) {
                throw error;
            }
        }

        async function loadWrappedKeys() {
            try {
                const db = await openDB();
                const tx = db.transaction('signalStore', 'readonly');
                const wrappedBundle = await tx.objectStore('signalStore').get('signalStore');
                return wrappedBundle || null;
            } catch (error) {
                return null;
            }
        }

        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
            return btoa(binary);
        }

        function base64ToArrayBuffer(base64) {
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
            return bytes.buffer;
        }

        function generateMessageId() {
            return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        }

        function isReplayAttack(messageId, timestamp) {
            if (Date.now() - timestamp > SECURITY_CONFIG.MAX_MESSAGE_AGE) return true;
            if (messageCache.has(messageId)) return true;
            messageCache.set(messageId, timestamp);
            if (messageCache.size > SECURITY_CONFIG.MAX_CACHED_MESSAGES) {
                const oldestEntries = Array.from(messageCache.entries()).sort((a, b) => a[1] - b[1]).slice(0, messageCache.size - SECURITY_CONFIG.MAX_CACHED_MESSAGES);
                oldestEntries.forEach(([id]) => messageCache.delete(id));
            }
            return false;
        }

        async function initializeKeyVerification() {
            const identityKeyPair = signalStore.getIdentityKeyPair();
            if (!identityKeyPair) throw new Error('No identity key pair found');
            const securityCode = await generateSecurityCode(identityKeyPair.pubKey);
            verifiedUsers.set(currentUser.uid, { publicKey: identityKeyPair.pubKey, securityCode: securityCode, verifiedAt: Date.now(), isCurrentUser: true });
            await loadVerifiedUsers();
            return securityCode;
        }

        async function loadVerifiedUsers() {
            try {
                const stored = localStorage.getItem(`verifiedUsers_${currentUser.uid}`);
                if (stored) verifiedUsers = new Map(JSON.parse(stored));
            } catch (error) {}
        }

        async function saveVerifiedUsers() {
            try {
                const data = Array.from(verifiedUsers.entries());
                localStorage.setItem(`verifiedUsers_${currentUser.uid}`, JSON.stringify(data));
            } catch (error) {}
        }

        async function verifyUserSecurityCode(userId, securityCode) {
            const userDoc = await db.collection('users').doc(userId).get();
            if (!userDoc.exists) return false;
            const userData = userDoc.data();
            if (!userData.keyBundle) return false;
            const computedCode = await generateSecurityCode(userData.keyBundle.identityPubKey);
            if (computedCode === securityCode) {
                verifiedUsers.set(userId, { publicKey: userData.keyBundle.identityPubKey, securityCode: computedCode, verifiedAt: Date.now() });
                await saveVerifiedUsers();
                return true;
            }
            return false;
        }

        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => screen.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        }

        function showError(elementId, message) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.style.display = 'block';
        }

        function hideError(elementId) {
            const element = document.getElementById(elementId);
            element.style.display = 'none';
        }

        async function signUp() {
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            try {
                hideError('auth-error');
                const userCredential = await auth.createUserWithEmailAndPassword(email, password);
                currentUser = userCredential.user;
                userDisplayName = email.split('@')[0];
                showScreen('passphrase-screen');
            } catch (error) {
                showError('auth-error', error.message);
            }
        }

        async function signIn() {
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            try {
                hideError('auth-error');
                const userCredential = await auth.signInWithEmailAndPassword(email, password);
                currentUser = userCredential.user;
                const wrappedKeys = await loadWrappedKeys();
                if (wrappedKeys) showScreen('unlock-screen');
                else { userDisplayName = email.split('@')[0]; showScreen('passphrase-screen'); }
            } catch (error) {
                showError('auth-error', error.message);
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('signup-btn').addEventListener('click', signUp);
            document.getElementById('signin-btn').addEventListener('click', signIn);
            document.getElementById('setup-encryption-btn').addEventListener('click', setupEncryption);
            document.getElementById('unlock-btn').addEventListener('click', handleUnlock);
            document.getElementById('complete-verification-btn').addEventListener('click', completeVerification);
            document.getElementById('skip-verification-btn').addEventListener('click', () => showScreen('chat-screen'));
            document.getElementById('security-info-btn').addEventListener('click', showSecurityInfo);
            document.getElementById('close-security-modal').addEventListener('click', closeSecurityModal);
            document.getElementById('logout-btn').addEventListener('click', signOut);
            document.getElementById('send-btn').addEventListener('click', sendMessage);
            document.getElementById('message-input').addEventListener('keypress', function(e) { if (e.key === 'Enter') sendMessage(); });
            auth.onAuthStateChanged((user) => { if (!user) showScreen('auth-screen'); });
            setupMessageListener();
        });

        async function setupEncryption() {
            const passphrase = document.getElementById('passphrase').value;
            const confirmPassphrase = document.getElementById('passphrase-confirm').value;
            if (!passphrase || passphrase.length < 8) { alert('Passphrase must be at least 8 characters long'); return; }
            if (passphrase !== confirmPassphrase) { alert('Passphrases do not match'); return; }
            try {
                document.getElementById('setup-encryption-btn').disabled = true;
                document.getElementById('setup-encryption-btn').textContent = 'Loading library...';
                
                await libraryLoadPromise;
                
                if (!libsignal) {
                    throw new Error('Signal Protocol library not loaded');
                }
                
                document.getElementById('setup-encryption-btn').textContent = 'Generating keys...';
                await generateAndRegisterKeys(currentUser.uid, signalStore);
                const wrappedBundle = await wrapStore(signalStore, passphrase);
                await storeWrappedKeys(wrappedBundle);
                const securityCode = await initializeKeyVerification();
                document.getElementById('user-security-code').textContent = securityCode;
                QRCode.toCanvas(document.getElementById('qr-code-container'), securityCode, function (error) { if (error) console.error('QR code generation error:', error); });
                showScreen('verification-screen');
            } catch (error) {
                alert('Error setting up encryption: ' + error.message);
                document.getElementById('setup-encryption-btn').disabled = false;
                document.getElementById('setup-encryption-btn').textContent = 'Setup Encryption';
            }
        }

        async function handleUnlock() {
            const passphrase = document.getElementById('unlock-passphrase').value;
            if (!passphrase) { showError('unlock-error', 'Please enter your passphrase'); return; }
            try {
                document.getElementById('unlock-btn').disabled = true;
                document.getElementById('unlock-btn').textContent = 'Unlocking...';
                const wrappedBundle = await loadWrappedKeys();
                if (!wrappedBundle) throw new Error('No encrypted keys found');
                const storeObj = await unwrapStore(wrappedBundle, passphrase);
                signalStore.fromObject(storeObj);
                await initializeKeyVerification();
                showScreen('chat-screen');
            } catch (error) {
                showError('unlock-error', 'Invalid passphrase or corrupted keys');
                document.getElementById('unlock-btn').disabled = false;
                document.getElementById('unlock-btn').textContent = 'Unlock';
            }
        }

        async function completeVerification() {
            const checkboxes = document.querySelectorAll('.verify-checkbox:checked');
            for (const checkbox of checkboxes) await verifyUserSecurityCode(checkbox.dataset.userid, checkbox.dataset.securitycode);
            await saveVerifiedUsers();
            showScreen('chat-screen');
        }

        function showSecurityInfo() { document.getElementById('security-modal').classList.add('active'); }
        function closeSecurityModal() { document.getElementById('security-modal').classList.remove('active'); }
        async function signOut() { try { await auth.signOut(); showScreen('auth-screen'); } catch (error) {} }

        async function sendMessage() {
            const messageInput = document.getElementById('message-input');
            const messageText = messageInput.value.trim();
            if (!messageText || !currentUser) return;
            try {
                await libraryLoadPromise;
                const messageId = generateMessageId();
                const usersSnapshot = await db.collection('users').get();
                const encryptedMessages = [];
                for (const userDoc of usersSnapshot.docs) {
                    if (userDoc.id === currentUser.uid) continue;
                    try {
                        let encryptedResult;
                        const recipientAddress = new libsignal.SignalProtocolAddress(userDoc.id, 1);
                        const sessionCipher = new libsignal.SessionCipher(signalStore, recipientAddress);
                        const plaintext = new TextEncoder().encode(messageText).buffer;
                        encryptedResult = await sessionCipher.encrypt(plaintext);
                        encryptedMessages.push({ userId: userDoc.id, encryptedMessage: JSON.stringify({ type: encryptedResult.type, body: arrayBufferToBase64(encryptedResult.body) }) });
                    } catch (sessionError) {
                        try {
                            encryptedResult = await startSessionAndSendMessage(userDoc.id, messageText, signalStore);
                            encryptedMessages.push({ userId: userDoc.id, encryptedMessage: JSON.stringify({ type: encryptedResult.ciphertext.type, body: arrayBufferToBase64(encryptedResult.ciphertext.body) }) });
                        } catch (startSessionError) {
                            displaySecurityWarning(`Cannot send to ${userDoc.data().displayName}: ${startSessionError.message}`);
                        }
                    }
                }
                if (encryptedMessages.length > 0) {
                    await db.collection('messages').add({
                        encryptedMessages: encryptedMessages,
                        senderId: currentUser.uid,
                        senderName: userDisplayName,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        messageId: messageId,
                        type: 'text'
                    });
                }
                displayMessage(messageText, currentUser.uid, true, { level: 'verified', text: '‚úÖ Sent securely' });
                messageInput.value = '';
                document.getElementById('char-count').textContent = '0';
            } catch (error) {
                alert('Error sending message: ' + error.message);
            }
        }

        function setupMessageListener() {
            db.collection('messages').orderBy('timestamp', 'asc').onSnapshot(async (snapshot) => {
                for (const change of snapshot.docChanges()) {
                    if (change.type === 'added') {
                        const message = change.doc.data();
                        const userMessage = message.encryptedMessages.find(msg => msg.userId === currentUser.uid);
                        if (userMessage) {
                            try {
                                await libraryLoadPromise;
                                const ciphertext = JSON.parse(userMessage.encryptedMessage);
                                const ciphertextMessage = { type: ciphertext.type, body: base64ToArrayBuffer(ciphertext.body) };
                                const decryptionResult = await receiveAndDecryptMessage(message.senderId, ciphertextMessage, signalStore);
                                if (!isReplayAttack(message.messageId, message.timestamp ? message.timestamp.toMillis() : Date.now())) {
                                    const verificationStatus = getMessageVerificationStatus(decryptionResult.sessionSafety, message.senderId);
                                    displayMessage(decryptionResult.plaintext, message.senderId, false, verificationStatus);
                                }
                            } catch (error) {
                                displayMessage('üîí [Encrypted message - decryption failed]', message.senderId, false, { level: 'error', text: 'üî¥ Decryption failed', description: error.message });
                            }
                        }
                    }
                }
            });
        }

        function getMessageVerificationStatus(sessionSafety, senderId) {
            const verifiedUser = verifiedUsers.get(senderId);
            if (!sessionSafety.decryptionSuccess) return { level: 'error', text: 'üî¥ Decryption failed', description: 'Message could not be decrypted' };
            if (sessionSafety.hasValidSession && sessionSafety.identityVerified) return { level: 'verified', text: '‚úÖ Verified contact', description: 'Encrypted and authenticated via secure session' };
            if (verifiedUser) return { level: 'verified', text: '‚úÖ Verified contact', description: 'Security code verified' };
            if (sessionSafety.decryptionSuccess) return { level: 'unverified', text: '‚ö†Ô∏è Unverified contact', description: 'Message decrypted but sender identity not verified' };
            return { level: 'unknown', text: '‚ùì Unknown security status', description: 'Unable to verify message authenticity' };
        }

        function displayMessage(text, senderId, isSent, verificationStatus) {
            const messagesContainer = document.getElementById('messages-container');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isSent ? 'sent' : 'received'}`;
            const messageContent = document.createElement('div');
            messageContent.textContent = text;
            messageDiv.appendChild(messageContent);
            const securityDiv = document.createElement('div');
            securityDiv.className = `message-${verificationStatus.level}`;
            securityDiv.textContent = verificationStatus.text;
            securityDiv.title = verificationStatus.description;
            messageDiv.appendChild(securityDiv);
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function displaySecurityWarning(message) {
            const messagesContainer = document.getElementById('messages-container');
            const warningDiv = document.createElement('div');
            warningDiv.className = 'security-indicator security-warning';
            warningDiv.textContent = `‚ö†Ô∏è SECURITY WARNING: ${message}`;
            messagesContainer.appendChild(warningDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
    </script>
</body>
</html>
